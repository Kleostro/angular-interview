
```TS
@if (loggedIn) {
  Пользователь вошел в систему
} @else {
  Пользователь не вошел в систему
}
```

Возможность напрямую предоставлять содержимое `@else` - это значительное упрощение по сравнению с пунктом `else` устаревшей альтернативы `*ngIf`. Текущий контроль потока также делает тривиальным наличие `@else if`, что исторически было невозможно.



```TS
@switch (accessLevel) {
  @case ('admin') { <admin-dashboard/> }
  @case ('moderator') { <moderator-dashboard/> }
  @default { <user-dashboard/> }
}
```

Новый контроль потока позволяет значительно улучшить сужение типов в отдельных ветвях в `@switch`, что невозможно в `*ngSwitch`.

```TS
@for (user of users; track user.id) {
  {{ user.name }}
} @empty {
  Empty list of users
}
```

Мы часто наблюдаем проблемы с производительностью в приложениях из-за отсутствия функции `trackBy` в `*ngFor`. Отличия `@for` заключаются в том, что функция `trackBy` является обязательной для обеспечения быстрой работы функции diffing. Кроме того, его гораздо проще использовать, поскольку это просто выражение, а не метод в классе компонента. Встроенный цикл `@for` также имеет возможность быстрого использования для коллекций с нулевыми элементами с помощью необязательного блока `@empty`.

Оператор `@for` использует новый diffing алгоритм и имеет более оптимальную реализацию по сравнению с `*ngFor`, что позволяет ему на 90% ускорить время выполнения в [бенчмарках сообщества](https://krausest.github.io/js-framework-benchmark/current.html)!


**Новые откладываемые представления позволяют лениво загрузить список комментариев и все их транзитивные зависимости одной строкой декларативного кода:**

```TS
@defer {
  <comment-list />
}
```

Самое невероятное заключается в том, что все это происходит посредством преобразования во время компиляции: Angular абстрагируется от всех сложностей, находя компоненты, директивы и пайпы, используемые внутри блока `@defer`, генерируя динамический импорт и управляя процессом загрузки и переключения между состояниями.

Ленивая загрузка компонента при попадании определенного DOM-элемента в область просмотра требует много более нетривиальной логики и использования API `IntersectionObserver`. Angular делает использование `IntersectionObservers` таким же простым, как добавление deferrable view триггера!

```TS
@defer (on viewport) {
  <comment-list />
} @placeholder {
  <!-- A placeholder content to show until the comments load -->
  <img src="comments-placeholder.png">
}
```

В приведенном примере Angular сначала отображает содержимое блока placeholder. Когда он становится видимым в области просмотра, начинается загрузка компонента `<comment-list / >`. По завершении загрузки Angular удаляет placeholder и отображает компонент.

Также имеются блоки для загрузки и состояния ошибки:

```TS
@defer (on viewport) {
  <comment-list/>
} @loading {
  Loading…
} @error {
  Loading failed :(
} @placeholder {
  <img src="comments-placeholder.png">
}
```

Вот и все! Под капотом находится множество сложностей, которыми Angular управляет за вас.

Deferrable views предлагают еще несколько триггеров:

- `on Idle` - ленивая загрузка блока, когда браузер не выполняет никакой тяжелой работы
    
- `on immediate` - начать ленивую автоматическую загрузку, не блокируя браузер
    
- `on timer(<time>)` - задержка загрузки с помощью таймера
    
- `on viewport` и`on viewport(<ref>)` - viewport также позволяет указать ссылку на якорный элемент. Когда элемент якоря становится видимым, Angular лениво загрузит компонент и отрендерит его
    
- `on interaction` и`on interaction(<ref>)` - позволяет инициировать ленивую загрузку при взаимодействии пользователя с определенным элементом
    
- `on hover` и`on hover(<ref>)` - запускает ленивую загрузку, когда пользователь наводит курсор на элемент
    
- `when <expr>` - позволяет задать собственное условие через выражение, возвращающее обещание